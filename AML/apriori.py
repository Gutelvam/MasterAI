
import matplotlib.pyplot as plt
from mlxtend.frequent_patterns import apriori, association_rules
import networkx as nx



class AprioriModel:
    """
    AprioriModel: A class for implementing the Apriori algorithm to identify frequent itemsets and generate association rules.

    Attributes:
        min_support (float): Minimum support threshold for frequent itemsets. Default is 0.01.
        min_lift (float): Minimum lift threshold for generating association rules. Default is 1.0.
        results (dict): A dictionary containing the frequent itemsets and association rules generated by the model.

    Methods:
        __init__(min_support=0.01, min_lift=1.0): Initializes the AprioriModel with specified support and lift thresholds.
        train(x, group_columns, agg_column, aggregation_function='sum', apply_filter=None): Fits the Apriori model on the provided dataset, identifies frequent itemsets, and generates association rules.
        _prepare_apriori_data(x, group_columns, agg_column, aggregation_function): Prepares the dataset for the Apriori algorithm by grouping, aggregating, and converting it into a binary matrix.
        get_results(): Returns the results of the Apriori algorithm, including frequent itemsets and association rules.
        plot_dashboard(freq_itemsets, rules): Visualizes the results of the Apriori model, including frequent itemsets, rule metrics, and a network graph of association rules.
    """

    def __init__(self, min_support=0.01, min_lift=1.0):
        """
        Initializes the Apriori model with given parameters.
        :param min_support: Minimum support for frequent itemsets.
        :param min_lift: Minimum lift for generating association rules.
        """
        self.min_support = min_support
        self.min_lift = min_lift
        self.results = {}

    def train(self, x, group_columns, agg_column, aggregation_function='sum', apply_filter=None):
        """
        Fits the Apriori model on the provided data.
        :param x: Input data (Pandas DataFrame).
        :param group_columns: Columns to group by (e.g., user and item).
        :param agg_column: Column to aggregate (e.g., purchase amount).
        :param aggregation_function: Function to aggregate the data (default is 'sum').
        :param apply_filter: Optional filtering condition (Pandas query string).
        """
        # Apply filter if specified
        if apply_filter:
            x = x.query(apply_filter).copy()

        # Prepare the data for Apriori
        x_binary = self._prepare_apriori_data(x, group_columns, agg_column, aggregation_function)

        # Run Apriori on the binary data
        freq_itemsets = apriori(x_binary, min_support=self.min_support, use_colnames=True)
        print(f"Frequent Itemsets:\n{freq_itemsets}")

        # Get the number of itemsets in freq_itemsets
        num_itemsets = len(freq_itemsets)
        print(f'Number of itemsets: {num_itemsets}')


        if freq_itemsets.empty:
            print("No frequent itemsets found. Try adjusting the support threshold or check your data.")
            return

        # Generate association rules with the correct parameters
        rules = association_rules(freq_itemsets, metric="lift", min_threshold=self.min_lift , num_itemsets=num_itemsets)

        # Store results for Apriori
        self.results = {
            "frequent_itemsets": freq_itemsets,
            "rules": rules
        }

        # Plot the dashboard with the results
        self.plot_dashboard(freq_itemsets, rules)

    def _prepare_apriori_data(self, x, group_columns, agg_column, aggregation_function):
        """
        Prepares the data for the Apriori algorithm by grouping, aggregating,
        pivoting, and converting it to a binary matrix.
        """
        # Group and aggregate the data
        x_grouped = x.groupby(group_columns, as_index=False).agg({agg_column: aggregation_function})
        print(f"Aggregated Data:\n{x_grouped.head()}")  # Check the aggregation results

        # Pivot the data to convert it into the right shape
        x_pivoted = x_grouped.pivot(index=group_columns[0], columns=group_columns[1], values=agg_column)
        print(f"Pivoted Data:\n{x_pivoted.head()}")  # Check the pivot results

        # Convert to binary matrix (1 if the item was bought, else 0)
        x_binary = x_pivoted.applymap(lambda x: 1 if x > 0 else 0)
        print(f"Binary Data for Apriori:\n{x_binary.head()}")  # Check the binary conversion

        return x_binary

    def get_results(self):
        """
        Returns the results of the Apriori model, including frequent itemsets and association rules.
        """
        return self.results



    def plot_dashboard(self, freq_itemsets, rules):
        fig, axs = plt.subplots(2, 2, figsize=(15, 12))

        # Plot Frequent Itemsets
        freq_itemsets.plot(kind="bar", x="itemsets", y="support", ax=axs[0, 0], legend=False)
        axs[0, 0].set_title("Frequent Itemsets - Support")
        axs[0, 0].set_xlabel("Itemsets")
        axs[0, 0].set_ylabel("Support")
        axs[0, 0].tick_params(axis='x', rotation=90)

        # Plot Support vs Confidence
        axs[0, 1].scatter(rules['support'], rules['confidence'], alpha=0.6, color='green')
        axs[0, 1].set_title('Support vs Confidence')
        axs[0, 1].set_xlabel('Support')
        axs[0, 1].set_ylabel('Confidence')

        # Plot Lift vs Confidence
        axs[1, 0].scatter(rules['lift'], rules['confidence'], alpha=0.6, color='blue')
        axs[1, 0].set_title('Lift vs Confidence')
        axs[1, 0].set_xlabel('Lift')
        axs[1, 0].set_ylabel('Confidence')

        # Plot Association Rules Network Graph
        G = nx.Graph()
        for _, row in rules.iterrows():
            antecedents = tuple(row['antecedents'])
            consequents = tuple(row['consequents'])
            G.add_edge(antecedents, consequents, weight=row['lift'])
        pos = nx.spring_layout(G, k=0.1, iterations=20)
        nx.draw(G, pos, with_labels=True, node_size=1000, node_color="lightblue", font_size=10, ax=axs[1, 1])
        axs[1, 1].set_title("Association Rules Network Graph")

        plt.tight_layout()
        plt.show()
